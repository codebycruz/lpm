local test = require("lpm-test")
local ffi = require("ffi")

local tcc = require("tcc")

test.it("tcc.new returns a state", function()
	local s = tcc.new()
	test.notEqual(s, nil)
	s:close()
end)

test.it("output type constants are defined", function()
	test.equal(tcc.OUTPUT_MEMORY, 1)
	test.equal(tcc.OUTPUT_EXE, 2)
	test.equal(tcc.OUTPUT_DLL, 3)
	test.equal(tcc.OUTPUT_OBJ, 4)
end)

test.it("compiles a valid C snippet without error", function()
	local s = tcc.new()
	s:compile("int foo(void) { return 42; }")
	s:close()
end)

test.it("compile errors on invalid C source", function()
	local s = tcc.new()
	local ok, err = pcall(function()
		s:compile("this is not valid C !!!!")
	end)
	test.equal(ok, false)
	s:close()
end)

test.it("relocate and symbol resolve a compiled function pointer", function()
	local s = tcc.new()
	s:compile("int add(int a, int b) { return a + b; }")
	s:relocate()
	local sym = s:symbol("add")
	test.notEqual(sym, nil)
	s:close()
end)

test.it("symbol errors for unknown symbol name", function()
	local s = tcc.new()
	s:compile("int x(void) { return 0; }")
	s:relocate()
	local ok, err = pcall(function()
		s:symbol("does_not_exist")
	end)
	test.equal(ok, false)
	s:close()
end)

test.it("compiled function returns the correct value when called", function()
	local s = tcc.new()
	s:compile("int square(int n) { return n * n; }")
	s:relocate()
	local sym = s:symbol("square")
	local fn = ffi.cast("int (*)(int)", sym)
	test.equal(fn(7), 49)
	s:close()
end)

test.it("two independent states do not share symbols", function()
	local s1 = tcc.new()
	s1:compile("int val(void) { return 1; }")
	s1:relocate()

	local s2 = tcc.new()
	s2:compile("int val(void) { return 2; }")
	s2:relocate()

	local fn1 = ffi.cast("int (*)(void)", s1:symbol("val"))
	local fn2 = ffi.cast("int (*)(void)", s2:symbol("val"))

	test.equal(fn1(), 1)
	test.equal(fn2(), 2)

	s1:close()
	s2:close()
end)

test.it("define injects a macro into compiled code", function()
	local s = tcc.new()
	s:define("ANSWER", "99")
	s:compile("int answer(void) { return ANSWER; }")
	s:relocate()
	local fn = ffi.cast("int (*)(void)", s:symbol("answer"))
	test.equal(fn(), 99)
	s:close()
end)

test.it("run() compiles and returns a callable symbol", function()
	local s = tcc.new()
	local sym = s:run("int triple(int n) { return n * 3; }", "triple")
	local fn = ffi.cast("int (*)(int)", sym)
	test.equal(fn(5), 15)
	s:close()
end)
